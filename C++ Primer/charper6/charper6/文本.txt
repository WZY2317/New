6.1:实参传递给形参参数，类型要匹配，函数调用使用形参。实参的数量和形参一样多。实参主要是初始化形参
6.2：略
6.3：略
6.4：略
6.5：略
6.6：形参和定义在函数里的普通变量都是局部变量，当加上static修饰时，称为静态局部变量，
它的值不会因为函数调用结束之后而销毁，生命周期贯穿函数调用以及之后的时间
6.13：引用不用拷贝实参，传递的就是实参
6.14：引用的时候为了避免拷贝比较大的对象，如果是不想要实参改变的那种就不使用引用
6.15：常量引用不可以被改变，对于待查找的字符很小，没必要使用引用传参 string s 比较大而且不需要被改变所以就使用常量引用
6.16：应该定义为const 引用，无法将普通的常量，const对象 或者是进行类型转换的对象传递给普通的引用形参
6.17：不相同，因为一个是不用改变string的值，一个要改变，所以参数一个是const引用 一个是普通引用
6.20:会给使用者一个错觉，这个参数可以改变，而且不可以传入常量对象和const对象，或者是要进行类型转换
6.24:不可以传递数组，应该传数组名，也就是指针，而且要显示的传入一个表示数组维度的参数
6.28:string
6.29:使用引用是为了避免拷贝长字符串
6.30:函数必须有返回值
6.31：返回局部变量的引用无效，不希望返回的对象被修改时，就返回常量的引用
6.34:参数传递可以是负数
6.35：val--是自减这会导致逻辑错误，后面的val的值就不对了
6.36：string (&func())[10];
6.37: typedef string arr[10]; arr& func() 
auto func() ->string& [10];string arr[10]; decltype(arr)& func()
6.38:decltype(odd)& arrptr(int i)
6.39:a:非法，无法区分int const int b：非法 不能只有返回类型不同， C:合法
6.43：a在源文件，b在头文件
6.44：略
6.45：内联函数应该是经常用的，而且是规模比较小，流程直接的

6.52:类型提升实现转换
6.53：a，b的第二条语句都合法，第三个不行是顶层const，指针本身是一个常量
6.54：int func(int,int) vector<decltype(func)*> vf
